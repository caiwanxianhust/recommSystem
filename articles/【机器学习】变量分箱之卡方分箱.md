**写在前面**：笔者在上一篇文章介绍了风控模型常用的编码方法——WOE，并对德国评分卡数据集Age字段进行了 binning+WOE 处理，着重介绍的是WOE的计算方法，本文将介绍一种常用的 binning 方法。

## 1 变量分箱的背景
### 1.1 什么是分箱
变量分箱是一种常用的特征工程方法，意在增强变量的可解释性与预测能力。变量分箱方法**主要用于连续变量**，对于变量取值较稀疏的离散变量也应该进行分箱处理（相当于将几个特征值合并为一个）。  
举个例子，比如借款人的地址信息，这是一个离散变量，借款人来自五湖四海，地址往往各不相同，这就导致地址这个变量非常稀疏，在进行特征工程时通常先对地址信息处理到省或市，然后用每个省或市的 bad rate（坏样本比率）进行数值化，最后将数值化后的变量作为连续变量进行分箱。

### 1.2 为什么要分箱？  
变量分箱对模型的好处可归纳为以下几点：  
- **降低异常值的影响，增加模型的稳定性**。数据中存在异常值时会使训练后的模型产生一定的偏差，从而影响预测效果。通过分箱方法可以降低异常值的噪声特性，使模型更稳健。树模型对异常值不敏感，因为树模型在进行特征选择时，模型内部针对连续变量进行了切分，选出了最优特征和最优切分点，这其实也是一种分箱处理；但逻辑回归和神经网络这类模型对异常值相对比较敏感，究其原因是因为其损失函数会将异常特征的值计算进去。
- **缺失值作为特殊变量参与分箱，减少缺失值填补的不确定性**。训练数据出现缺失值的情况太常见了，如用户录入错误、操作人员的失误、多个数据源字段不统一或数据存储故障等等问题都在导致数据出现缺失值。大部分机器学习模型本身都是无法处理缺失值的，都需要特征工程进行处理。树模型可以处理缺失值，比如决策树模型在树的构建过程中，如果遇到有缺失值的变量，在计算信息增益或Gini系数时会忽略缺失值，用非缺失值计算一个值，再将缺失值的比例作为一个影响因子考虑进来；在划分样本时则将缺失值样本以不同的权重同时划入所有子节点。虽然树模型提供了缺失值解决方案，但是对有缺失值的样本做出的判断并不准确，所以无论是树模型还是其他模型，缺失值填补的工作必不可少。分箱方法可以将缺失值作为特殊值参与分箱处理。通常的做法是，离散特征将缺失值转为字符串作为特殊字符即可，而连续特征将缺失值作为特殊值即可，这样，缺失值将作为一个特征参与分箱，免去主观填充带来的不确定性问题。
- **增加变量可解释性**。分箱的方法往往要配合变量编码使用，这就大大提高了变量的可解释性。通常采用的编码方式为WOE编码，具体编码方法笔者上一篇文章中详细介绍过，可见[【机器学习】WOE：证据权重](https://mp.weixin.qq.com/s/5bL2WIpTGo7Z5YcGpDVdEw)
- **增加模型非线性效果**。变量分箱相当于把变量特征进行了归纳，将一系列特征值归纳为几类，这其实也是一种非线性变换。另外分箱之后还会进行编码处理，通常一个特征会分化为几个特征各自有自己的权重，增加了模型的表达能力。
- **使训练集和测试集更容易保持同分布**。机器学习模型在训练时会将数据划分为训练集和测试集，通常假设训练集与测试集的样本是服从同分布的，分箱操作将连续变量离散化，使得训练集和测试集更容易满足同分布假设。因此，分箱会增加模型预测效果的稳定性，减小模型在训练集与测试集上效果的偏差。

上面说的全是优点，那么变量分箱有没有局限性呢？当然有，归纳如下：
- **同一箱内的样本具有同质性**。以年龄为例，上一篇文章中笔者把借款人年龄分为四个箱：`0-20 Teenager， 21-40 Young， 41-55 Middle， 56-120 Old`。也就是说把年龄 `21~41` 之间的借款人统一按照一个数值变量来代替，这客观上导致了信息的损失，降低了模型的上限。
- **需要业务经验支持**。不同的变量分箱对模型预测结果的影响是不同的，最好需要业务经验进行分箱指导，这往往非常耗时，代价较高。

### 1.3 分箱需要注意什么，有哪些小技巧？
变量分箱需要注意以下问题：
- **分箱数量不宜过多**。因为分箱后需要用编码的方式进行数值转化，转化的方式为 WOE 编码或 One-hot 编码。如果分箱过多，会造成有些箱内样本过少，导致这些样本少的箱内样本分布不具备代表性。
- **分箱结果不宜过少**。前面有说，分箱会导致同一个箱内样本具有同质性，分箱数量越少，信息损失越多。分箱是一个样本信息归纳的过程，相当于一次聚类操作，过多则失去了归纳的意义，过少则损失信息太多得不偿失。
- **分箱后的特征值最好能够和 Odds 或者 Bad Rate 呈现单调关系**。分箱单调性是指 binning+WOE 可以把基于对数几率的非线性非单调的特征转化为线性。这一点笔者上一篇文章有介绍，是为了让 Logistic 回归模型可以得到更好的预测结果。

### 1.4 如何对变量进行分箱？
变量分箱的目的是对变量信息进行归纳总结，增加模型的预测能力的同时减少变量的信息冗余。当预测能力不再提升或冗余性不再降低时，则分箱完毕。因此，分箱过程是一个优化过程，所有满足上述要求的指标都可以用于变量分箱，这个指标也可叫作目标函数，可以终止或改变分箱的限制就是优化过程的约束条件。
常用的目标函数有**卡方值、KS值、IV值、WOE值、信息熵和 Gini 值**等，只要是可以提高变量的预测能力或减少变量自身冗余的指标，都可以作为目标函数使用。
优化的约束条件可以是**分箱数限制（一般不要大于10箱）、每组内最小样本数（WOE值计算要求好坏样本数不能为0）、每组内最多样本数（不希望分箱后样本分布非常不均衡）、组间距离限制（切分点不能太接近）、Early stopping策略**的限制（继续切分已经不会带来目标函数的更大提升而停止继续切分）、WOE单调或baterate单调。
上面的目标函数和约束条件看起来是不是有点似曾相识？**是的，和树模型差不多**。对于目标函数而言，说白了**一组好的分箱可以减小样本集的条件熵，使得在该分箱条件下样本集的分类确定性更高**，这点相当于树模型的特征选择与特征值切分。对于约束条件而言，也和树模型的分裂约束条件、停止条件差不多。
目标函数和约束条件应该在变量分箱操作前就先确定下来。

<img src="https://mmbiz.qpic.cn/mmbiz_png/GJUG0H1sS5pZRaM9uasdPyHAgaayqwyiccdD52EgmT54QUoV3wLzibk0iaYpokxFfGXzcMhSu2lKopSib39nCcCVqw/0?wx_fmt=png" style="zoom: 200%;" />

上图是一个变量分箱的常规流程，详细介绍如下：
- 初始化分箱数 nbins=1，就是说，一开始只有一个箱。
- 初始化切分点。对于连续变量可以采用等距离切分；对于离散变量变量的值天然就是切分点，如果变量非常稀疏，则可以先用坏样本比率数值化，然后按照连续变量分箱操作。
- 判断切分之后每个箱内样本数是否大于最小样本数，如果小于，需要重新选择切分点。
- 判断是否达到最大分箱数（或者其他停止条件），如果达到，分箱结束。
- 计算每个切分点下的目标函数值，找到最优切分点。
- 计算最优切分点下的增益值。
- 如果最优切分点下的增益值大于给定阈值，则分箱成功，如果小于阈值则分箱结束。

## 2 最优Chi-merge卡方分箱
卡方分箱是一种常用的变量自动分箱方法，提到卡方分箱不得不先介绍一下什么是卡方。
### 2.1 卡方分布
#### 2.1.1 卡方分布的数学定义
卡方分布(chi-square distribution, 又写作$\chi ^2$ -distribution)，是常用于概率论和统计检验中的一种概率分布，在假设检验与置信区间的计算中经常能见到卡方分布的身影。其定义如下：
若 $k$ 个相互独立的随机变量 $Z_1, Z_2,..., Z_k$ 满足标准正态分布 $N(0,1)$ , 则这 $k$ 个随机变量的平方和服从自由度为 $k$ 的卡方分布：
$$
X = \sum ^k_{i=1} Z_i^2
$$
记作，
$$
X \sim \chi ^2(k)
$$
或者，
$$
X \sim \chi ^2_k
$$

#### 2.1.2 卡方分布的特征
自由度为 $k$ 的卡方分布，其期望为 $k$，方差为 $2k$。其概率密度函数为：
$$
f_k(x) = 
\begin {cases}
\frac{(1/2)^{k/2}}{\Gamma (k/2)} x^{k/2 -1} e^{-x/2} , \quad x>0 \\
0 , \quad x \leq 0
\end {cases}
$$
其中， $\Gamma$ 是伽马函数。
其概率密度函数图像如下所示：

```python
plt.figure(figsize=(14, 9))
#PDF    K=1
plt.plot(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=1), color='#008fd5')
plt.fill_between(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=1), color='#008fd5', alpha=0.15)
#PDF    K=2
plt.plot(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=2), color='#fc4f30')
plt.fill_between(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=2), color='#fc4f30', alpha=0.15)
#PDF    K=3
plt.plot(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=3), color='#e5ae38')
plt.fill_between(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=3), color='#e5ae38', alpha=0.15)
#PDF    K=4
plt.plot(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=4), color='#2e8b57')
plt.fill_between(np.linspace(0,15,100),stats.chi2.pdf(np.linspace(0,15,100),df=4), color='#2e8b57', alpha=0.15)
#LEGEND 图例
plt.text(x=0.5,y=0.7,s="$ k=1$",rotation=-65,alpha=.75,weight="bold",color='#008fd5')
plt.text(x=1.0,y=.35,s="$ k=2$",alpha=.75,weight="bold",color="#fc4f30")
plt.text(x=2,y=.22,s="$ k=3$",alpha=.75,weight="bold",color="#e5ae38")
plt.text(x=4,y=.18,s="$ k=4$",alpha=.75,weight="bold",color="#2e8b57")
#Ticks 坐标轴
plt.tick_params(axis="both",which="major",labelsize=18)
plt.axhline(y=0,color="black",linewidth=1.3,alpha=.7)
```
![](https://mmbiz.qpic.cn/mmbiz_png/GJUG0H1sS5oP6P5k7EcFfWyJepic2ic0aBic6A9zBvP1Pic3XBb39vMawkb6C7IBhf6GljlzhuMsH2LrmQCsIgHd4Q/0?wx_fmt=png)

卡方分布的累积分布函数为：
$$
F_k(x) = \frac {\gamma (k/2,x/2)}{\Gamma (x/2)}
$$
其中，$\gamma$ 为不完全Gamma函数。
其累积分布函数图像如下所示：

```python
plt.figure(figsize=(14, 9))
#PDF    K=1
plt.plot(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=1), color='#008fd5')
plt.fill_between(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=1), color='#008fd5', alpha=0.15)
#PDF    K=2
plt.plot(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=2), color='#fc4f30')
plt.fill_between(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=2), color='#fc4f30', alpha=0.15)
#PDF    K=3
plt.plot(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=3), color='#e5ae38')
plt.fill_between(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=3), color='#e5ae38', alpha=0.15)
#PDF    K=4
plt.plot(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=4), color='#2e8b57')
plt.fill_between(np.linspace(0,15,100),stats.chi2.cdf(np.linspace(0,15,100),df=4), color='#2e8b57', alpha=0.15)
#LEGEND 图例
plt.text(x=2,y=0.9,s="$ k=1$",alpha=.75,weight="bold",color='#008fd5')
plt.text(x=3,y=.85,s="$ k=2$",alpha=.75,weight="bold",color="#fc4f30")
plt.text(x=3.8,y=.8,s="$ k=3$",alpha=.75,weight="bold",color="#e5ae38")
plt.text(x=4,y=.7,s="$ k=4$",alpha=.75,weight="bold",color="#2e8b57")
#Ticks 坐标轴
plt.tick_params(axis="both",which="major",labelsize=18)
plt.axhline(y=0,color="black",linewidth=1.3,alpha=.7)
```
![](https://mmbiz.qpic.cn/mmbiz_png/GJUG0H1sS5oP6P5k7EcFfWyJepic2ic0aBlYGgmfyD5gibWfZMdbzlKsgZfKVBE4XJMRk9EjG0vMibNuFQbxDWCQAQ/0?wx_fmt=png)

卡方分布可以用来测试随机变量之间是否相互独立（独立性检验），也可用来检测统计模型是否符合实际要求（拟合优度检验）。
### 2.2 卡方检验
卡方检验是（chi-square test）是一种基于卡方分布的常用的统计（显著性）检验，其统计量在原假设（null hypothesis）成立时服从卡方分布。在不明确说明的情况下，卡方检验默认指代皮尔森卡方检验（Pearson's chi-squared test），根据样本数据推断总体分布与期望分布是否有显著差异，或推断分类变量间是否相互关联或彼此独立。

卡方检验通常分为两种：拟合优度检验和独立性检验。

卡方检验的一般步骤如下：
- 设置原假设
- 设置显著性水平 $\alpha$
- 根据问题选择具体的假设检验方式
- 计算卡方值，并通过卡方值获取 `p` 值
- 根据P值与显著性水平，决定接受原假设还是拒绝原假设。如卡方值大于给定置信水平的理论值（一般取0.95）或求得的p值小于给定的阈值（一般为0.05），则拒绝原假说，即实测值与理论值的差异在置信水平下是显著的。

卡方值计算公式如下：
$$
\chi ^2_k = \sum \frac{(A - E)^2}{E}
$$
其中，$A$ 为实际频数，$E$ 为期望频数。

#### 2.2.1 卡方拟合优度检验
卡方拟合优度检验是一种非参数检验方法，其用于研究样本实际分布情况是否与预期分布表现一致，它只针对于类别数据，其自由度为类别总数减1。

卡方拟合优度检验的原理在于如果实际频数与预期频数差值特别大，则卡方值特别大，对应的 `p` 值也会特别小，这时候表示期望分布与实际分布有明显的差异性；反之如果基本没有差异，那么实际频数和预期频数之间差值很小，则卡方值很小，计算得到的 `p` 值会很大，表示期望与实际之间没有差异性。

下面以一个简单的例子来说明。
笔者认为借款人的性别分布是没有差异的，即男女各占50%，于是笔者搜集了1000个借款人的性别信息，由于原假设认为男女各占一半，因此男女的期望频数都是500。以下为实际频数与期望频数的列联表。
|     | 男 | 女 |
|:---:|:---:|:---:|
|实际值|690|310|
|期望值|500|500|
第一步，我们假设借款人的性别分布是均衡的，第二布设置显著性水平 $\alpha = 0.5$，第三步确定使用卡方拟合优度检验，第四步计算卡方值和 `p` 值。
$$
自由度： \quad k = 2 - 1 = 1 \\
卡方值： \quad \chi ^ 2 _1 = \frac {(690-500)^2}{500} + \frac {(310-500)^2}{500} = 144.4
$$
```python
stats.chisquare([690, 310], [500, 500])

#output:
Power_divergenceResult(statistic=144.4, pvalue=2.904943341006629e-33)
```
可以看出卡方值很大，通过查询卡方分布的临界值表 $\alpha = 0.05，k=1$ 对应的临界概率是：3.84，卡方值144.4远大于临界值，同时`p` 值远小于显著性水平，所以拒绝原假设，借款人的性别分布是不均衡的。

#### 2.2.2 卡方独立性检验
独立性检验主要用于两个或两个以上因素多项分类的计数资料分析，也就是研究两类变量之间的关联性和依存性问题。

独立性检验一般采用列联表的形式记录观察数据, 列联表是由两个以上的变量进行交叉分类的频数分布表，是用于提供基本调查结果的最常用形式，可以清楚地表示定类变量之间是否相互关联。与拟合优度检验不同，独立性检验的自由度 $k=(m-1)(n-1)$，其中 $m,n$ 分别为列联表的行数、列数。

下面同样以一个简单的例子来说明。
笔者认为借款人的出国经历与是否违约是相互独立的，即两者不相关，于是笔者搜集了1000个借款人的出国经历、违约信息，整理成列联表如下。

|     | 不违约 | 违约 | 合计 |
|:---:|:---:|:---:|:---:|
|出国|667|296|963|
|没出国|33|4|37|
|合计|700|300|1000|

期望频数表：
|     | 不违约 | 违约 |
|:---:|:---:|:---:|
|出国|963*700/1000=674 |963*300/1000=289|
|没出国|37*700/1000=26|37*300/1000=11|

同样的，第一步，我们假设借款人的出国经历与是否违约是相互独立的，第二布设置显著性水平 $\alpha = 0.5$，第三步确定使用卡方独立性检验，第四步计算卡方值和 `p` 值。
$$
自由度： \quad k = (2 - 1)(2 - 1) = 1 \\
卡方值： \quad \chi ^ 2 _1 = \frac {(667-674)^2}{674} + \frac {(296-289)^2}{289} + \frac {(33-26)^2}{26} + \frac {(4-11)^2}{11} = 6.581
$$
```python
stats.chisquare([667, 296, 33, 4], [674, 289, 26, 11], ddof=1)

#output:
Power_divergenceResult(statistic=6.581411308907125, pvalue=0.03722757032453947)
```
通过查询卡方分布的临界值表 $\alpha = 0.05，k=1$ 对应的临界概率是：3.84。由于卡方值 $6.581 > 3.84$，同时`p` 值 $0.037<0.05$，即小于显著性水平 $\alpha$，所以拒绝原假设，借款人的出国经历与是否违约是相关的。

### 2.3 卡方分箱
#### 2.3.1 卡方分箱原理
Chi-merge卡方分箱方法是一种自底向上的分箱方法，其思想是将原始数据初始化为多个数据区间，并对相邻区间的样本进行合并，计算合并后的卡方值，用卡方值的大小衡量相邻区间中类分布的差异情况。卡方值越小，表明该相邻区间的类分布情况越相似，可以进行区间合并；反之，卡方值越大，则表明该相邻区间的类分布情况越不同，不能进行区间合并操作。卡方值计算公式如下：
$$
\chi ^2_k = \sum _{i=1}^{n} \sum_{j=1}^{m} \frac {(A_{ij} - E_{ij})^2}{E_{ij}}
$$
其中，`n` 表示区间数，因为是相邻区间进行合并，所以 `n=2`；`m` 表示类别数，如二分类 `m=2`。$E_{ij}$  表示第 `i` 个区间第 `j` 个类别的期望值，计算方式是第 `j` 个类别在总体样本中的占比乘以第 `i` 个区间的全部样本数。$A_{ij}$ 表示第 `i` 个区间第 `j` 类样本的实际个数。

#### 2.3.2 卡方分箱流程
卡方分箱过程主要包括两个阶段：初始化阶段和自底向上的合并阶段。
- （1）初始化阶段：
  - 首先按照属性值的大小进行排序（对于非连续特征，需要先做数值转换，比如转为Bad Rate后排序），然后每个属性值单独作为一组。
- （2）合并阶段：
  - （2.1）对每一对相邻的组，计算卡方值。
  - （2.2）根据计算的卡方值，对其中最小的一对邻组合并为一组。
  - （2.3）不断重复（2.1）（2.2）直到计算出的卡方值都不低于事先设定的阈值，或者分组数达到一定的条件（如最小分组数5，最大分组数8）。

<font face="楷体" size=2 color="blue">**注意**:在计算相邻组卡方值时，统计期望频数的时候只考虑在此两组内的样本，不可以按总体样本分布来计算！原因很简单，我们是按卡方值最小来决定是否需要合并，如果只考虑相邻两组内的样本，卡方值越小表示这两组的分布越接近；如果按总体分布计算卡方值，卡方值小只能说明这两组样本的分布接近总体分布，并不能说明比其他组合样本分布更纯粹。
</font>

#### 2.3.3 卡方分箱实战
以上卡方分箱流程，Python实现如下（笔者原创，亲测可用）：
```python
class ChiSqureMerge:
    def __cal_chi2(self, df, col, target):
        '''
        用来计算区间内的卡方值，其中期望频率是按照区间内样本分布来计算的。该函数为私有函数，不在类外使用。
        df：DataFrame，列联表，至少包含:col, target, good_target, bad_cnt, good_cnt这几列
        col：str，待分箱列名
        target：str，label值列名，0、1
        return：
            chi2：float，卡方值
        '''
        bindf = df.copy()
        bad_rate = bindf["bad_cnt"].sum() / (bindf["bad_cnt"].sum() + bindf["good_cnt"].sum())
        good_rate = 1 - bad_rate
        bindf["expect_good_cnt"] = (bindf["bad_cnt"] + bindf["good_cnt"]) * good_rate
        bindf["expect_bad_cnt"] = (bindf["bad_cnt"] + bindf["good_cnt"]) * bad_rate
        # 这里为了防止期望频数为0导致零除报错，简单处理将分母+1
        bindf["chi2"] = (bindf["good_cnt"] - bindf["expect_good_cnt"]) ** 2 / (bindf["expect_good_cnt"] + 1) + \
(bindf["bad_cnt"] - bindf["expect_bad_cnt"]) ** 2 / (bindf["expect_bad_cnt"] + 1)
        return bindf["chi2"].sum()
    
    def chi2_merge(self, df, col, target, maxInterval=5, chi_threshold=None):
        '''
        1、根据最大区间数限制
        2、最小卡方值限制
        df：DataFrame，原始数据集，至少包含：col, target
        col：str，待分箱列
        target：str， label值列名，0、1
        maxInterval：int，最少箱数
        chi_threshold：float，卡方阈值，当前轮最小的卡方值如果大于阈值就停止
        return:
            bins：list in list箱。
        '''
        bindf = df[[col, target]].copy()
        bindf["good_target"] = 1 - bindf[target]
        # 获得频数列联表
        bindf = pd.crosstab(bindf[col], bindf[target]).reset_index()
        bindf.columns = [col, "good_cnt", "bad_cnt"]
        bin_cnt = len(bindf)
        # 初始化桶
        bins = [[i] for i in bindf[col].values.tolist()]
        if chi_threshold is None:
            chi_threshold = 1e9
        min_chiSquare = 0.
        while (min_chiSquare < chi_threshold and bin_cnt > maxInterval):
            bins_chi2 = []
            for idx, val in enumerate(bins[:-1]):
                # 合并区间
                start_index = bindf[bindf[col] == val[0]].index.tolist()[0]
                end_index = bindf[bindf[col] == bins[idx+1][-1]].index.tolist()[0]
                bins_chi2.append((idx, self.__cal_chi2(bindf.loc[start_index:end_index, :], col, target)))
            min_dix, min_chiSquare = sorted(bins_chi2, key=lambda x:x[1])[0]
            bins[min_dix] += bins[min_dix+1]
            bins.pop(min_dix + 1)
            bin_cnt = len(bins)
        return bins
```

再回到德国评分卡数据集，以年龄字段为例进行分箱，首先导入数据并进行简单预处理。
```python
import pandas as pd
import numpy as np
from scipy import stats


df = pd.read_csv("./data/german.csv", header=None, delim_whitespace=True)
# 变量名
columns = ['status_account', 'duration', 'credit_history', 'purpose', 'amount','svaing_account', 'present_emp', 
           'income_rate', 'personal_status', 'other_debtors', 'residence_info', 'property', 'age', 'linst_plans',
           'housing', 'num_credits', 'job', 'dependents', 'telephone', 'foreign_worker', 'target']
df.columns = columns
# 将标签减1转化为0、1。其中，0表示好用户，没有发生违约；1表示坏用户，发生了违约。
df['target'] -= 1
```
看一下真实的年龄分布。
```python
plt.figure(figsize=(16,12))
age_plot = sns.distplot(df['age'])
age_plot.set_title("Age Distribuition", fontsize=18)
age_plot.set_xlabel("age")
age_plot.set_ylabel("Probability", fontsize=15)
```

![](https://mmbiz.qpic.cn/mmbiz_png/GJUG0H1sS5ptJrUNuZjT5olag7FASvt3ibRZjzeOEGRFHMiaLzSBbicWxd7gEHNNReguKFvIydRdaYFJ0ZKKMKZSA/0?wx_fmt=png)

可以看出，借款人最小的有19岁，最大的有75岁，主要集中于20到40岁之间。

对年龄进行分箱，计划分5个箱，卡方阈值这里就不指定了。
```python
chi2m = ChiSqureMerge()
bins = chi2m.chi2_merge(df, "age", "target")
bins

"""
#output:
[[19, 20, 21, 22, 23, 24, 25],
 [26, 27, 28, 29, 30, 31, 32, 33, 34],
 [35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52],
 [53, 54, 55, 56, 57, 58, 59, 60, 61],
 [62, 63, 64, 65, 66, 67, 68, 70, 74, 75]]
"""
```
共产生了5个箱，即`(19, 25]、(25, 34]、(34,52]、(52, 61]、(61, 75]`，这里最大值 `75` 和最小值 `19` 只是针对这1000个数据而言的，为了使分好的箱兼容将来新的数据，可以对界限稍作处理。即`(-1e9, 25]、(25, 34]、(34,52]、(52, 61]、(61, 1e9]`，这里正负`1e9`代表以上（或以下）。
```python
bins = [b[-1] for b in bins]
bins = [-1e9, ] + bins[:-1] + [1e9]
bins

"""
#output:
[-1000000000.0, 25, 34, 52, 61, 1000000000.0]
"""
```
将 `bins` 传给 `pd.cut()` 就可以完成最终分箱，可以看出，`df` 多了一个列名为 `age_cut` 的列，这就是分箱后的结果。
```python
df["age_cut"] = pd.cut(df["age"], bins=bins, labels=["a", "b", "c", "d", "e"])
df.head()

"""
#output:
  status_account  duration credit_history purpose  amount svaing_account  \
 0            A11         6            A34     A43    1169            A65   
 1            A12        48            A32     A43    5951            A61   
 2            A14        12            A34     A46    2096            A61   
 3            A11        42            A32     A42    7882            A61   
 4            A11        24            A33     A40    4870            A61   
 
   present_emp  income_rate personal_status other_debtors  ...  age  \
 0         A75            4             A93          A101  ...   67   
 1         A73            2             A92          A101  ...   22   
 2         A74            2             A93          A101  ...   49   
 3         A74            2             A93          A103  ...   45   
 4         A73            3             A93          A101  ...   53   
 
   linst_plans  housing num_credits   job  dependents telephone  \
 0        A143     A152           2  A173           1      A192   
 1        A143     A152           1  A173           1      A191   
 2        A143     A152           1  A172           2      A191   
 3        A143     A153           1  A173           2      A191   
 4        A143     A153           2  A173           2      A191   
 
    foreign_worker target age_cut  
 0            A201      0       e  
 1            A201      1       a  
 2            A201      0       c  
 3            A201      0       c  
 4            A201      1       d  
 
 [5 rows x 22 columns])
"""
```

## 3 小结
本文详细介绍了变量分箱、卡方分布、卡方检验、卡方分箱四个知识点，由浅入深，循序渐进，是笔者对金融风控知识点的一个小总结，如有错误，欢迎指正。